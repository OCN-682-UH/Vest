---
title: "Week_4b_Lecture_Notes"
output: html_document
---

```{r}
What function do you use to subset rows by some criterion?
  #filter

How do I add a new column to my data frame?
  #mutate
```

```{r}
### Today we are going to practice tidy with biogeochemistry data from Hawaii ####
### Created by: Jordan Vest #############
### Updated on: 2025-09-18 ####################
#### Load Libraries ######
library(tidyverse)
library(here)
### Load data ######
ChemData<-read_csv(here("Week_04","data", "chemicaldata_maunalua.csv"))
View(ChemData)
glimpse(ChemData)
```

```{r}
ChemData_clean<-ChemData %>%
  filter(complete.cases(.)) #filters out everything that is not a complete row
View(ChemData_clean)

drop_na(ChemData)
```


```{r}
?separate
separate(
data = [data frame you are using],
col = [column that you want to separate],
into = [name of the new columns],
sep = [what are you separating by?])

ChemData_clean<-ChemData %>%
  drop_na() %>% #filters out everything that is not a complete row
  separate(col = Tide_time, #choose the tide time col
           into = c("Tide","Time"), #separate it into two columns tide and time
           sep = "_" )  #separate by _
head(ChemData_clean)
```


```{r}
Notice this deletes the original column. If we wanted to keep it we would add remove = FALSE. So if we want to keep it

ChemData_clean<-ChemData %>%
  drop_na() %>% #filters out everything that is not a complete row
  separate(col = Tide_time, # choose the tide time col
           into = c("Tide","Time"), # separate it into two columns Tide and time
           sep = "_", # separate by _
           remove = FALSE) # keep the original tide_time column
head(ChemData_clean)
```

```{r}
Unite! your columns...
ChemData_clean<-ChemData %>%
  drop_na() %>% #filters out everything that is not a complete row
  separate(col = Tide_time, # choose the tide time col
           into = c("Tide","Time"), # separate it into two columns Tide and time
           sep = "_", # separate by _
           remove = FALSE) # keep the original tide_time column
  unite(col = "Site_Zone", # the name of the NEW col
        c(Site,Zone), # the columns to unite
        sep = ".", #lets put a . in the middle
        remove = FALSE) #keep the original
head(ChemData_clean)
```
```{r}
ChemData_clean<-ChemData %>%
  drop_na() %>% #filters out everything that is not a complete row
  separate(col = Tide_time, # choose the tide time col
           into = c("Tide","Time"), # separate it into two columns Tide and time
           sep = "_", # separate by _
           remove = FALSE) %>% # keep the original tide_time column
  unite(col = "Site_Zone", # the name of the NEW col
        c(Site,Zone), # the columns to unite
        sep = ".",  #lets put a . in the middle
        remove = FALSE) # keep the original
head(ChemData_clean)
```

```{r}
Wide data: one observation per row and all the different variables are columns
Wide to long: pivot_longer()
ex. We want one column with all the names of the biogeochemical parameters (i.e., NN, P, Si, etc)
Paired with one column with all the values associated with those variables
We want all the metadata (lat, long, tide, etc.) to be preserved in the correct order
Why is long format helpful?
Easier to summarize using group_by(). You would only need to group by the variable name to get all summary statistics for every variable
Easier to facet_wrap() by each variable if all the plots are going to be identical instead of making 10 individual plots

Long data: one unique measurement per row and all the info about that measurement is in the same row
Long to wide: pivot_wider()

```

```{r}
ChemData_long<-ChemData_clean %>%
  pivot_longer(cols = Temp_in:percent_sgd, # the cols you want to pivot
               names_to = "Variables", # the names of the new cols with all the column names
               values_to = "Values") # names of the new column with all the values
View(ChemData_long)
#What can we do with the long data set?
ChemData_long %>%
  group_by(Variables, Site) %>% # group by everything we want
  summarise(Param_means = mean(Values, na.rm = TRUE), # get mean
            Param_vars = var(Values, na.rm = TRUE)) # get variance
```
#allowed us to use a few lines of code rather than 16 to solve for each variable

```{r}
#Challenge: Calculate mean, variance, and std.dev. for all variable by site, zone, and tide
ChemData_long %>%
  group_by(Variables, Site) %>% # group by everything we want 
  summarise(Param_means = mean(Values, na.rm = TRUE), # get mean 
            Param_vars = var(Values, na.rm = TRUE)) # get variance
View(ChemData_long)
```
```{r}
ChemData_long %>%
  group_by(Variables, Zone) %>% # group by everything we want 
  summarise(Param_means = mean(Values, na.rm = TRUE), # get mean 
            Param_vars = var(Values, na.rm = TRUE)) # get variance
View(ChemData_long)
```

```{r}
ChemData_long %>%
  group_by(Variables, Tide) %>% # group by everything we want 
  summarise(Param_means = mean(Values, na.rm = TRUE), # get mean 
            Param_vars = var(Values, na.rm = TRUE)) # get variance
View(ChemData_long)
```

```{r}
ChemData_long %>%
  ggplot(aes(x = Site, y = Values))+
  geom_boxplot()+
  facet_wrap(~Variables) # not very useful if all are scaled the same
```

```{r}
ChemData_long %>%
  ggplot(aes(x = Site, y = Values))+ 
  geom_boxplot()+ 
  facet_wrap(~Variables, scales = "free")
#"free_y" or "free_x" if you need it; quick and easy visualization for long data
```

```{r}
ChemData_wide<-ChemData_long %>%
  pivot_wider(names_from = Variables, # column with the names for the new columns
              values_from = Values) # column with the values
View(ChemData_wide)
#note, we just replace to with from
```

```{r}
ChemData_clean<-ChemData %>%
  drop_na() %>% #filters out everything that is not a complete row
  separate(col = Tide_time, # choose the tide time col
           into = c("Tide","Time"), # separate it into two columns Tide and time
           sep = "_", # separate by _
           remove = FALSE) %>%
  pivot_longer(cols = Temp_in:percent_sgd, # the cols you want to pivot. This says select the temp to percent SGD cols  
               names_to = "Variables", # the names of the new cols with all the column names 
               values_to = "Values") %>% # names of the new column with all the values 
  group_by(Variables, Site, Time) %>% 
  summarise(mean_vals = mean(Values, na.rm = TRUE)) %>%
  pivot_wider(names_from = Variables,
              values_from = mean_vals) # notice it is now mean_vals as the col name
write_csv(here("Week_04","Outputs","summary.csv")) #export as a. csv to the right folders
```

